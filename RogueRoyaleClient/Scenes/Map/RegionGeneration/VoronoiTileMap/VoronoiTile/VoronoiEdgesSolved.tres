[gd_resource type="Shader" format=2]

[resource]
code = "shader_type canvas_item;

// a function that gives a random float between 0 and 1
float rand(ivec2 uv){
    return fract(sin(dot(vec2(uv), vec2(12.9898, 78.233))) * 43758.5453);
}

// a function that returns a random vec2 between 0 and 1
vec2 rand_vec2(ivec2 uv){
    return vec2(rand(uv), rand(uv));
}

float voronoiDistance( in vec2 x )
{
    ivec2 p = ivec2(floor( x ));
    vec2  f = fract( x );

    //----------------------------------
    // first pass: regular voronoi
    //----------------------------------

    ivec2 mb;
    vec2 mr;

    float res = 8.0;
    for( int j=-1; j<=1; j++ )
    for( int i=-1; i<=1; i++ )
    {
        ivec2 b = ivec2(i, j);
        vec2  r = vec2(b) + rand_vec2(p+b)-f;
        float d = dot(r,r);

        if( d < res )
        {
            res = d;
            mr = r;
            mb = b;
        }
    }

    //----------------------------------
    // second pass: distance to borders
    //----------------------------------

    res = 8.0;
    for( int j=-2; j<=2; j++ )
    for( int i=-2; i<=2; i++ )
    {
        ivec2 b = mb + ivec2(i, j);
        vec2  r = vec2(b) + rand_vec2(p+b) - f;
        float d = dot(0.5*(mr+r), normalize(r-mr));

        res = min( res, d );
    }
    return res;
}

float getBorder( in vec2 p )
{
    float d = voronoiDistance( p );
    return 1.0 - smoothstep(0.0,0.05,d);
}

void fragment(){
	//COLOR = vec4(vec3(getBorder(8.0 * UV)), 1.0);
    float vd = voronoiDistance( 8.0 * UV );
    vec3 c = vec3(vd);
	// isolines
    //vec3 col = c.x*(0.5 + 0.5*sin(64.0*c.x))*vec3(1.0);
    vec3 col = vec3(1.0, 0.6, 0.0);
	// borders	
    col = mix( vec3(1.0,0.6,0.0), col, smoothstep( 0.04, 0.07, c.x ) );
    // feature points
	float dd = length( c.yz );
	col = mix( vec3(1.0,0.6,0.1), col, smoothstep( 0.0, 0.12, dd) );
	col += vec3(1.0,0.6,0.1)*(1.0-smoothstep( 0.0, 0.04, dd));

	COLOR = vec4(col,1.0);

}
"
