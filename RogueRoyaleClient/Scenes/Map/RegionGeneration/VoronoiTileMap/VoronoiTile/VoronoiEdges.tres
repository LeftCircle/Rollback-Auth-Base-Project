[gd_resource type="Shader" format=2]

[resource]
code = "shader_type canvas_item;

// A better solution is here https://iquilezles.org/articles/voronoilines/


uniform float width_mod : hint_range(0.0, 10.0, 0.0001) = 1.0;
uniform float dist_to_dot : hint_range(0.0, 1.0, 0.1) = 0.1;
uniform float edge_width : hint_range(0.0, 1.0, 0.0001) = 0.0001;

uniform vec4 middle_color : source_color = vec4(0.0, 0.0, 0.0, 1.0);

uniform vec4 color : source_color = vec4(0.0, 0.0, 0.0, 1.0);
uniform vec2 random_point = vec2(0.5, 0.5);

uniform vec2 random_top_left = vec2(-0.5, -0.5);
uniform vec4 tl_color : source_color = vec4(0.0, 0.0, 0.0, 1.0);

uniform vec2 random_top = vec2(0.5, -0.5);
uniform vec4 t_color : source_color = vec4(0.0, 0.0, 0.0, 1.0);

uniform vec2 random_top_right = vec2(1.5, -0.5);
uniform vec4 tr_color : source_color = vec4(0.0, 0.0, 0.0, 1.0);

uniform vec2 random_left = vec2(-0.5, 0.5);
uniform vec4 l_color : source_color = vec4(0.0, 0.0, 0.0, 1.0);

uniform vec2 random_right = vec2(1.5, 0.5);
uniform vec4 r_color : source_color = vec4(0.0, 0.0, 0.0, 1.0);

uniform vec2 random_bottom_left = vec2(-0.5, 1.5);
uniform vec4 bl_color : source_color = vec4(0.0, 0.0, 0.0, 1.0);

uniform vec2 random_bottom = vec2(0.5, 1.5);
uniform vec4 b_color : source_color = vec4(0.0, 0.0, 0.0, 1.0);

uniform vec2 random_bottom_right = vec2(1.5, 1.5);
uniform vec4 br_color : source_color = vec4(0.0, 0.0, 0.0, 1.0);

vec2 random(vec2 uv) {
	return vec2(fract(sin(dot(uv.xy,
		vec2(12.9898,78.233))) * 43758.5453123));
}

float lerp(float a, float b, float pct){
	return (a + (b - a)) * pct;
}

void voronoi_color_check(vec2 uv, vec2 rp, inout float min_dist, inout float second_min, inout vec2 closest_point,
						inout vec2 second_closest, inout vec4 current_color, vec4 set_color, inout vec4 cc, inout vec4 scc){
	float test_distance = distance(uv, rp);
	if (test_distance < min_dist){
		second_closest = closest_point;
		second_min = min_dist;
		min_dist = test_distance;
		current_color = set_color;
		closest_point = rp;
		scc = cc;
		cc = set_color;
	} else if (test_distance < second_min){
		second_min = test_distance;
		second_closest = rp;
		scc = set_color;
	}
}

void middle_color_check(vec2 uv, vec2 closest_point, vec2 second_closest, inout vec4 current_color, vec4 cc, vec4 scc){
	float dist_to_closest = distance(uv, closest_point);
	float dist_to_second = distance(uv, second_closest);
	float modded_dist = abs(dist_to_closest - dist_to_second);
	//current_color = modded_dist < edge_width ? middle_color : current_color;
	if (modded_dist <= edge_width && scc - cc != vec4(0)){
		float percent = 1.0 - (modded_dist / (edge_width));
		float m = smoothstep(0.0, 1.0, percent);
		//float m = lerp(0.0, 1.0, percent);
		current_color = mix(current_color, middle_color, m);
	}
//	if (dist_to_second - dist_to_closest <= edge_width){
//		float percent = 1.0 - (dist_to_second - dist_to_closest) / edge_width - 0.5;
//		current_color = mix(cc, scc, percent);
//	}
		//current_color = mix(scc, cc, m);
}

vec4 voronoi_tilemap(vec2 uv){
	vec4 return_color = color;
	float m_dist = 5.0;
	float second_min = 5.0;
	vec2 closest_point = vec2(10.0);
	vec2 second_closest_point = vec2(10.0);
	// closest color and second closest color
	vec4 cc = vec4(1.0);
	vec4 scc = vec4(1.0);
	voronoi_color_check(uv, random_top_left, m_dist, second_min, closest_point, second_closest_point, return_color, tl_color, cc, scc);
	voronoi_color_check(uv, random_top, m_dist, second_min, closest_point, second_closest_point, return_color, t_color, cc, scc);
	voronoi_color_check(uv, random_top_right, m_dist, second_min, closest_point, second_closest_point, return_color, tr_color, cc, scc);
	voronoi_color_check(uv, random_left, m_dist, second_min, closest_point, second_closest_point, return_color, l_color, cc, scc);
	voronoi_color_check(uv, random_point, m_dist, second_min, closest_point, second_closest_point, return_color, color, cc, scc);
	voronoi_color_check(uv, random_right, m_dist, second_min, closest_point, second_closest_point, return_color, r_color, cc, scc);
	voronoi_color_check(uv, random_bottom_left, m_dist, second_min, closest_point, second_closest_point, return_color, bl_color, cc, scc);
	voronoi_color_check(uv, random_bottom, m_dist, second_min, closest_point, second_closest_point, return_color, b_color, cc, scc);
	voronoi_color_check(uv, random_bottom_right, m_dist, second_min, closest_point, second_closest_point, return_color, br_color, cc, scc);
	if (distance(uv, random_point) < dist_to_dot){
		return_color = vec4(1.0);
	}
	middle_color_check(uv, closest_point, second_closest_point, return_color, cc, scc);
	return return_color;
}

void fragment() {
	vec4 voronoi_tile = voronoi_tilemap(UV);
	COLOR = voronoi_tile;
}
"
